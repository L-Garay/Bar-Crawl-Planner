import { createMachine } from 'xstate';

// can start the machine when the user hits the /authenticate route (if they are properly authenticated)
// at that point we know we they are a registered user who can start using the machine
// we'll need to implement a way for the front end to signal to the server that the user has logged out (currently logging out is all client side)
// at that point we can stop the machine, since we'll know they are no longer a registered user

// each time a user selects a nofitication, we need to make sure to put it into context so we can derive what stae it's in

// when a user takes any action with regards to a notification, we will need to set that notification and it's corresponding most relevant status, into the machine context using .withContext() and passing in the data
// then at that point, we will be able to access the notitication and status in the functions used for the guarded transitions
// the guards will be used to determine the current state of the notification and then determine what the next state should be

// which means that the intitial state of the machine should be something like 'unkown' or 'undefined' or 'uninitialized' or something that means that 'there isn't a notification selected yet'
// then within that state, we will have a transition for each possible state that the already created notification could be in
// FOR EXAMPLE: if userA sends userB a friend request, assume it was already moved from 'unkown' to 'created' to 'sent'
// now suppose 5 days have passed since then, and userB is just now opening the app and seeing the notification
// userB's state machine will be started once they log in
// once they navigate to the notifications page and select the Friend request notification to see the detials and respond, AT THIS POINT we need to set that notification and it's corresponding status in the machine context
// AT THIS POINT, since we know that the notification is in the 'sent' state and not opened, we can transition to the 'opened' state
// which means that from the 'unkown' state, we will have a transition to the 'sent' state
// from there once the user accepts, declines or deletes the notification, we will transition to the 'accepted', 'declined' or 'deleted' state

const notificationMachine = createMachine(
  {
    id: 'notifications',
    initial: 'unkown',
    context: {
      notification: {},
      notificationStatus: {},
    },
    states: {
      unkown: {
        on: {
          IS_SENT: {
            target: 'sent',
          },
          IS_OPENED: {
            target: 'opened',
          },
          IS_ACCEPTED: {
            target: 'accepted',
          },
          IS_DECLINED: {
            target: 'declined',
          },
          IS_DELETED: {
            target: 'deleted',
          },
        },
      },
      created: {
        on: {
          SEND: {
            target: 'sent',
            actions: 'generateNotificationStatus',
          }, // transition to sent state
        },
      },
      sent: {
        entry: [],
        on: {
          OPEN: {
            target: 'opened',
            actions: 'generateNotificationStatus',
          }, // transition to opened state
          DELETE: {
            target: 'deleted',
            actions: 'generateNotificationStatus',
          }, // transition to deleted state
        },
      },
      opened: {
        entry: [],
        on: {
          ACCEPT: {
            target: 'accepted',
            actions: ['generateNotification', 'generateNotificationStatus'],
          }, // transition to accepted state
          DECLINE: {
            target: 'declined',
            actions: 'generateNotificationStatus',
          }, // transition to declined state
          DELETE: {
            target: 'deleted',
            actions: 'generateNotificationStatus',
          }, // transition to deleted state
        },
      },
      accepted: {
        entry: [],
        on: {
          DELETE: {
            target: 'deleted',
            actions: 'generateNotificationStatus',
          }, // transition to deleted state
        },
      },
      declined: {
        entry: [],
        on: {
          DELETE: {
            target: 'deleted',
            actions: 'generateNotificationStatus',
          }, // transition to deleted state
        },
      },
      deleted: {
        type: 'final',
        onDone: {
          actions: 'deleteNotification',
        },
      },
    },
  },
  {
    actions: {
      generateNotification: (context, event) => {
        // use context and event to generate either outingNotification or friendNotification and respective status
      },
      deleteNotification: (context, event) => {
        // use context and event to update notification status to deleted
      },
      generateNotificationStatus: (context, event) => {
        // use context and event to update notification status
      },
    },
  }
);
